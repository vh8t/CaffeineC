package compiler

import (
	"os"
	"strings"

	"github.com/llir/llvm/ir/types"
)

func convertCffTypeToCType(t types.Type) string {
	switch typ := t.(type) {
	case *types.IntType:
		if typ.BitSize <= 8 {
			return "char"
		} else if typ.BitSize <= 16 {
			return "short"
		} else if typ.BitSize <= 32 {
			return "long"
		} else {
			return "long long"
		}
	case *types.FloatType:
		if typ.Kind == types.FloatKindFloat {
			return "float"
		} else if typ.Kind == types.FloatKindDouble {
			return "double"
		} else {
			return "long double"
		}
	case *types.PointerType:
		// Call the function recursively with the ElemType and append a star before it
		return convertCffTypeToCType(typ.ElemType) + " *"
	default:
		return "void"
	}
}

func WriteHeader(f *os.File, comp *Compiler) error {
	_, err := f.WriteString("/*\n")
	if err != nil {
		return err
	}

	_, err = f.WriteString(" * This file was automatically generated by CaffeineC.\n")
	if err != nil {
		return err
	}

	_, err = f.WriteString(" * Do not edit this file directly.\n")
	if err != nil {
		return err
	}

	_, err = f.WriteString(" */\n")
	if err != nil {
		return err
	}

	_, err = f.WriteString("#ifndef CAFFEINEC_H\n")
	if err != nil {
		return err
	}

	_, err = f.WriteString("#define CAFFEINEC_H\n")
	if err != nil {
		return err
	}

	for _, fn := range comp.Module.Funcs {
		if strings.Count(fn.Name(), ".") > 0 {
			continue
		}
		_, err = f.WriteString(convertCffTypeToCType(fn.Sig.RetType) + " ")
		if err != nil {
			return err
		}

		_, err = f.WriteString(fn.Name())
		if err != nil {
			return err
		}

		_, err = f.WriteString("(")
		if err != nil {
			return err
		}

		for i, param := range fn.Sig.Params {
			_, err = f.WriteString(convertCffTypeToCType(param))
			if err != nil {
				return err
			}

			_, err = f.WriteString(" ")
			if err != nil {
				return err
			}

			_, err = f.WriteString(fn.Params[i].Name())
			if err != nil {
				return err
			}

			if i != len(fn.Sig.Params)-1 {
				_, err = f.WriteString(", ")
				if err != nil {
					return err
				}
			}
		}

		if fn.Sig.Variadic {
			_, err = f.WriteString(", ...")
			if err != nil {
				return err
			}
		}

		_, err = f.WriteString(")")
		if err != nil {
			return err
		}

		_, err = f.WriteString(";\n")
		if err != nil {
			return err
		}
	}

	for _, c := range comp.Module.TypeDefs {
		_, err = f.WriteString("class " + c.Name() + "\n{\nprivate:\n")
		if err != nil {
			return err
		}

		for _, field := range comp.StructFields[c.Name()] {
			if !field.Private {
				continue
			}
			_, err = f.WriteString(convertCffTypeToCType(comp.Context.StringToType(field.Type)) + " " + field.Name + ";\n")
			if err != nil {
				return err
			}
		}

		_, err = f.WriteString("public:\n")
		if err != nil {
			return err
		}

		for _, field := range comp.StructFields[c.Name()] {
			if field.Private {
				continue
			}
			_, err = f.WriteString(convertCffTypeToCType(comp.Context.StringToType(field.Type)) + " " + field.Name + ";\n")
			if err != nil {
				return err
			}
		}

		for _, fn := range comp.Module.Funcs {
			var parts []string
			if strings.Count(fn.Name(), ".") == 0 {
				continue
			} else {
				parts = strings.Split(fn.Name(), ".")
				if parts[0] != c.Name() {
					continue
				}
			}

			isConstructor := parts[1] == "constructor"

			if !isConstructor {
				_, err = f.WriteString(convertCffTypeToCType(fn.Sig.RetType) + " ")
				if err != nil {
					return err
				}

				_, err = f.WriteString(parts[1])
				if err != nil {
					return err
				}
			} else {
				_, err = f.WriteString(c.Name())
				if err != nil {
					return err
				}
			}

			_, err = f.WriteString("(")
			if err != nil {
				return err
			}

			for i, param := range fn.Sig.Params[1:] {
				_, err = f.WriteString(convertCffTypeToCType(param))
				if err != nil {
					return err
				}

				_, err = f.WriteString(" ")
				if err != nil {
					return err
				}

				_, err = f.WriteString(fn.Params[i+1].Name())
				if err != nil {
					return err
				}

				if i != len(fn.Sig.Params)-2 {
					_, err = f.WriteString(", ")
					if err != nil {
						return err
					}
				}
			}

			_, err = f.WriteString(")")
			if err != nil {
				return err
			}

			_, err = f.WriteString(";\n")
			if err != nil {
				return err
			}
		}

		_, err = f.WriteString("};\n")
		if err != nil {
			return err
		}
	}

	_, err = f.WriteString("#endif\n")
	if err != nil {
		return err
	}

	return nil
}
